## 메모리 단편화(Memory Fragmentation)

메모리의 공간이 작은 조각으로 나뉘어져 사용가능한 메모리가 충분히 존재하지만 할당(사용)이 불가능한 상태



**내부 단편화(Internal Fragmentation)**

 메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 프로세스에서 사용하는 메모리 공간이 낭비 되는 상황



**외부 단편화(External Fragmentation)**

 메모리가 할당되고 해제되는 작업이 반복될 때 작은 메모리가 중간중간 존재하게 된다. 이 때 중간중간에 생긴 사용하지 않는 메모리가 많이 존재해서 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황



### 메모리 파편화 문제 해결 방안



**1. 페이징 기법** - 가상 메모리 사용, 외부 단편화 해결, 내부 단편화 존재

- **프레임(Frame)**: <u>물리 메모리</u>를 일정된 한 크기로 나눈 블록
- **페이지(Page)**: <u>가상 메모리</u>를 일정된 한 크기로 나눈 블록

페이징 기법이란 사용하지 않는 프레임을 페이지에 옮기고, 필요한 메모리를 페이지 단위로 프레임에 옮기는 기법

페이지와 프레임을 대응시키기 위해 page mapping과정이 필요해서 색인(페이지 번호)와 물리 메모리(프레임)의 시작 주소를 가진 paging table을 만든다. 

 <u>연속적이지 않은 공간도 활용</u>할 수 있기 때문에 **외부 단편화 문제를 해결**할 수 있다. 대신 페이지 단위에 알맞게 꽉채워 쓰는게 아니므로 내부 단편화 문제는 발생한다.

* 페이지 단위를 작게하면 내부 단편화 문제도 해결할 수 있겠지만 대신 page mapping 과정이 많아지므로 오히려 효율이 떨어질 수 있다.



**2. 세그멘테이션 기법** - 가상 메모리 사용, 내부 단편화 해결, 외부 단편화 존재

- **세그먼트(Segment)** - <u>가상 메모리</u>를 다른 크기로 나눈 단위

세그멘테이션기법이란 가상메모리를 세그먼트로 분할해서 메모리를 할당하여 실제 메모리 주소로 변환하는 기법

세그먼트와 프레임을 대응시키기위해 segment mapping과정이 필요해서 세그먼트 시작주소와 세그먼트 길이 정보, 물리 메모리(프레임)의 시작 주소를 가진 segment table을 만든다.

 각 세그먼트는 <u>연속적인 공간에 저장</u>에 프로세스가 필요한 메모리 만큼 할당해주기 때문에 **내부단편화는 해결** 가능하나 여전히 중간에 프로세스가 메모리를 해제하면 생기는 구멍, 즉 외부 단편화 문제는 여전히 존재한다.



**3. 페이징 / 세그멘테이션 혼용기법**

1. 프로세스를 세그먼트 단위로 나눈다.
2. 나눈 세그먼트를 페이지 단위로 나눈다.
3. 각 세그멘트를 페이지로 구분했기 때문에 각 세그멘트당 페이지 테이블이 존재한다.

- **논리주소** =  세그먼트의 번호 + 세그먼트 크기 + 프레임 번호(페이지 테이블의 시작 주소)

- **물리주소** = 프레임 번호 + 변위

두 개의 사상 테이블을 유지, 관리가 필요하며

<u>마지막 페이지에서 내부 단편화 현상 발생</u>

출처: https://jeong-pro.tistory.com/91 

출처:  https://blog.naver.com/PostView.nhn?blogId=wndrlf2003&logNo=220137749751 