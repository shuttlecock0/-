# 소프트웨어 생명주기

소프트웨어 생명주기(SDLC: Software Development Life Cycle)은 소프트웨어를 체계적으로 관리하기 위해서 개발 과정을 단계별로 나누어 구분한 것

<img src="https://user-images.githubusercontent.com/47841725/67177135-1a51e080-f408-11e9-8c59-5835b09105f6.png">

##### 1. 요구분석 (Requirement analysis) 

- 소프트웨어의 **기능**과 **제약조건**, **목표** 등을 소프트웨어 사용자와 함께 명확히 정의하는 단계
- 개발할 소프트웨어의 성격을 정확히 이해하고 개발 방법과 필요한 개발 자원 및 예산 예측 후 **요구사항명서세** 작성

##### 2. 시스템 명세 (System Specification)

- 시스템이 무엇을 수행해야 하는가를 정의하는 단계
- 입력 자료, 처리 내용, 생성되는 출력이 무엇인지 정의 후 **시스템 기능 명세서** 작성

##### 3. 설계 단계 (Design)

- 시스템 명세 단계에서 정의한 기능을 실제로 수행하기 위한 방법을 논리적으로 결정하는 단계
- 시스템, 프로그램, UI 설계로 구성
  - 시스템 구조 설계 - 시스템을 구성하는 내부 프로그램이나 모듈 간의 관계와 구조 설계
  - 프로그램 설계 - 프로그램 내의 각 모듈에서의 처리 절차나 알고리즘을 설계
  - 사용자 인터페이스 설계 - 사용자가 시스템을 사용하기 위해 보여지는 부분 설계
- 설계 방법 종류
  - 하향식 설계 (Top-dwon Design)
    - 하위 단계로 갈수록 더 구체적으로 세부 문제를 정의
    - 마지막으로 최하위 단계로 분할된 작은 단위 문제들을 각각 처리함으로써 전체문제 해결
  - 상향식 설계 (Bottom-up Design)
    - 최하위 단계의 작은 단위를 먼저 해결하고, 이를 이용해 상위 단계의 문제를 해결한다.
    - 최하위 단위의 문제들에 대해 기존에 개발되어 있는 문제해결 도구를 재사용하는 경우 개발 기간과 비용 단축, 신뢰성 확보 가능
  - 객체지향 설계(Object-oriented Design)
    - 하위 단위의 문제해결 도구를 재사용한다는 점에서 상향식 설계와 유사
    - 작은 단위의 문제에 대해 문제해결을 위한 데이터와 처리방법을 묶어서 객체를 만들고, 객체를 재사용

##### 4. 구현 단계 (Implementation)

- 설계 단계에서 논리적으로 결정한 문제 해결 방법(알고리즘)을 프로그래밍언어를 사용하여 실제 프로그램을 작성하는 단계

- 사용자의 요구, 프로그래머의 능력, 현재 사용중인 언어, 컴파일러의 가용성과 품질, 지원 가능한 개발도구, 언어의 호환성, 개발 경험 등을 고려

  - **가용성(Availability)** 

    - 서버와 네트워크, 프로그램 등의 정보 시스템이 정상적으로 사용 가능한 정도

    - 정상적인 사용 시간(Uptime)을 전체 사용 시간(Uptime+Downtime)으로 나눈 값 

      <img src="https://user-images.githubusercontent.com/47841725/67179012-d6fb7000-f40f-11e9-9226-34efac92b52d.png">

##### 5. 테스트 단계 (Test)

- 개발한 시스템이 요구사항을 만족하는지, 실행결과가 예상한 결과와 정확하게 맞는지를 검사하고 평가하는 일련의 과정

  - 1단계: **단위 테스트 (Unit Test)** - 시스템의 최소 구성요소가 되는 모듈에 대해서 개별적으로 시행

  - 2단계: **통합 테스트 (Integration Test)** - 단위 테스트를 통과한 모듈을 연결하여 전체 시스템으로 완성하여 통합적으로 시행하는 테스트

  - 3단계: **인수 테스트 (Acceptance Test)** - 시스템을 완성된 제품으로 보고 실제 데이터를 사용하여 시스템을 테스트하는 과정, 실질적으로 시스템이 사용되기 위해 마지막으로 시행되는 테스트

    - **알파 테스트** (관리자, 개발자)
    - **베타 테스트** (사용자)

    

##### 6. 유지보수 단계 (Maintenance)

- 시스템이 인수되고 설치된 후 일어나는 모든 활동 (커스터마이징, 구현, 테스트 ... 등)
- 소프트웨어 생명주기에서 **가장 긴 기간**
- 요지보수 유형
  - 수정형 유지보수 - 사용 중에 발견한 프로그램의 오류 수정 작업
  - 적응형 유지보수 - 시스템과 관련한 환경적 변화에 적응하기 위해 재조정 작업
  - 완전형 유지보수 - 시스템의 성능을 향상시키기 위한 개선 작업
  - 예방형 유지보수 - 앞으로 발생할지 모를 변경 사항을 수용하기 위한 대비 작업



참고자료:  https://dream-director.tistory.com/106 



# 소프트웨어 생명주기 모델

#### 1. 주먹구구식 개발 모델 (Build and Fix Model)

- 요구사항 분석, 설계 등의 단계없이 개발에 들어간 후 만족할 때까지 수정작업 진행
- 장점: 개발 시작이 빠름
- 단점: 계획이 정확하지 않음



#### 2. 폭포수 모델 (Waterfall Model)

- Boehem이 제시한 **고전적** 생명 주기 모델로 **선형 순차적** 모델

- 단계별 산출물이 명확함

- 응용분야가 단순하거나, 잘 알고 있는 경우에 적합하며, 생명주기 전반에 걸쳐 변경이나 진화가 예상되지 않는, 비교적 위험이 적은 프로젝트에 적합한 모델

- 장점: 체계적인 문서화로 프로젝트 진행을 명확하게 함.

- 단점: 이전 단계가 완료될 때까지 대기상태, 실제 작동되는 시스템을 개발 후반부에 확인 가능하기 때문에 고객이 요구사항 적용을 확인하는데 많은 시간이 걸림.

- 원칙적으로는 병행되어 진행되거나, 거슬러 반복 진행 X

- 실제 프로젝트에 적용하다보면, 불가피하게도 **피드백**을 통해 거슬러 반복되 

  

  <img src="https://user-images.githubusercontent.com/47841725/67184229-4710f280-f41e-11e9-87b8-530ed806060e.png">



#### 3. 원형 모델, 프로토타이핑 모델 (Prototyping Model)

- 고객의 요구사항을 정확히 파악하기 어려울때 사용하는 모델

- 점진적으로 시스템을 개발

- 프로토타입을 먼저 개발해 고객 요구사항을 구체적으로 도출

- 장점: 원형을 바탕으로 빠른 개발과 고객의 피드백을 받을 수 있음, 요구분석 용이, 개발 타당성 검증 가능

- 단점: 대규모의 프로젝트에는 부적합, 프로토타입 폐기에 따른 비용 증가

  <img src="https://user-images.githubusercontent.com/47841725/67185667-5180bb80-f421-11e9-8a6d-538e67a0335e.png">



#### 4. 나선형 모델 (Spiral Model)

- Boehm이 제안했으며 폭포수 모델과 원형 모델의 장점에 **위험분석**을 추가한 점증적 개발 모델

-  **목표설정, 위험요소 분석 및 해결, 개발 및 검증, 계획 수립**의 네 부분으로 구성

- 점진적으로 프로토 타입을 발전시켜 나가면서 완벽한 시스템으로 개발하는 방식이기 때문에 고비용, 대규모 시스템 개발에 적합함

- 장점: 위험성 감소와 변경에 유연한 대처

- 단점: 단계 반복에 따른 공정관리 어려움

  <img src="https://user-images.githubusercontent.com/47841725/67187873-277dc800-f426-11e9-82df-71be69cda482.png">



#### 5. RAD 모델 (Rapid Application Development Model)

- 아주 <u>짧은 개발주기(**2~3개월**)</u>동안 소프트웨어를 개발하기 위한 선형순차적인 프로세스 모델

- 툴을 사용해서 디자인을 하고 Code Generator로 소스를 생성하여 프로그램을 빠르게 개발하는 기법

- **고객참여**: 고객에 의한 요구사항 정의, 분석, 설계

- 기술위험(Risk)가 적고, **신속한 개발** 필요시 사용

  <img src="https://user-images.githubusercontent.com/47841725/67191116-0f10ac00-f42c-11e9-8879-2ec929235609.png">

  <img src="https://user-images.githubusercontent.com/47841725/67191202-349db580-f42c-11e9-8eb1-b90ccb4e08c5.png">

#### 6. 반복적 개발 모델 (Iterative Development Model)

- 증분형(Incremental)
- 진화형(Evolutional)

#### 7. V모델 (V Model)



#### 8. 컴포넌트 기반 모델 (Component Based Development Model)



이미지 출처:  소프트웨어 공학 [최은만 저, 정익사] 

자료 출처:  https://needjarvis.tistory.com/192 